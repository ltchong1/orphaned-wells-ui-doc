"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5390],{20835:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"concepts/docai","title":"Document Processing","description":"Document processing workflow with DocAI","source":"@site/docs/concepts/docai.mdx","sourceDirName":"concepts","slug":"/concepts/docai","permalink":"/orphaned-wells-ui-doc/docs/concepts/docai","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Document Processing","description":"Document processing workflow with DocAI","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Concepts","permalink":"/orphaned-wells-ui-doc/docs/concepts/"},"next":{"title":"Installation","permalink":"/orphaned-wells-ui-doc/docs/install/"}}');var o=t(74848),s=t(28453);const r={title:"Document Processing",description:"Document processing workflow with DocAI",sidebar_position:3},d="Document processing with DocAI",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Terminology",id:"terminology",level:2},{value:"Workflow",id:"workflow",level:2},{value:"Split",id:"split",level:3},{value:"Training",id:"training",level:4},{value:"Application",id:"application",level:4},{value:"Classify",id:"classify",level:3},{value:"Training",id:"training-1",level:4},{value:"Application",id:"application-1",level:4},{value:"Extract",id:"extract",level:3},{value:"Training",id:"training-2",level:4},{value:"Application",id:"application-2",level:4}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"document-processing-with-docai",children:"Document processing with DocAI"})}),"\n",(0,o.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsx)(n.p,{children:"The current deployment of OGRRE uses Google DocAI for digitizing documents."}),"\n",(0,o.jsx)(n.p,{children:"This page describes the workflow used to process well records through DocAI."}),"\n",(0,o.jsx)(n.h2,{id:"terminology",children:"Terminology"}),"\n",(0,o.jsx)(n.p,{children:"Following are terms used in this page:"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Term"}),(0,o.jsx)(n.th,{children:"Synonyms"}),(0,o.jsx)(n.th,{children:"Definition"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"model"}),(0,o.jsx)(n.td,{children:"AI model"}),(0,o.jsx)(n.td,{children:"Trained (DocAI) model that can transform inputs to outputs"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"collated documents"}),(0,o.jsx)(n.td,{children:"Raw PDFs"}),(0,o.jsx)(n.td,{children:"Multiple-page PDFs containing well records"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"splitter"}),(0,o.jsx)(n.td,{}),(0,o.jsx)(n.td,{children:"AI model that can extract the PDF pages from collated documents"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"category"}),(0,o.jsx)(n.td,{}),(0,o.jsx)(n.td,{children:"A label that identifies a type of document"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"training document"}),(0,o.jsx)(n.td,{}),(0,o.jsx)(n.td,{children:"Document used to train an AI model"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"testing document"}),(0,o.jsx)(n.td,{}),(0,o.jsx)(n.td,{children:"Document used to assess the accuracy of the AI model as part of the model training"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"classifier"}),(0,o.jsx)(n.td,{}),(0,o.jsx)(n.td,{children:"AI model that groups documents into categories for processing"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"schema"}),(0,o.jsx)(n.td,{}),(0,o.jsx)(n.td,{children:"Set of attributes that are expected for a document in a given category"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"field"}),(0,o.jsx)(n.td,{children:"attribute"}),(0,o.jsx)(n.td,{children:"One named value in a document"})]})]})]}),"\n",(0,o.jsx)(n.h2,{id:"workflow",children:"Workflow"}),"\n",(0,o.jsx)(n.p,{children:"Below is a diagram showing an overview of the workflow:"}),"\n",(0,o.jsx)(n.mermaid,{value:'flowchart TD\r\n    subgraph Split\r\n        direction LR\r\n        doc_raw([raw PDFs])\r\n        doc_split(["`split documents *name_category_count*`"])\r\n        mod_split_m[Model]\r\n        mod_split[/Split the documents/]\r\n        mod_split_label[/training/]\r\n\r\n        doc_raw --\x3e mod_split_label --\x3e mod_split_m\r\n        doc_raw --\x3e mod_split\r\n        mod_split_m --\x3e mod_split\r\n        mod_split --\x3e doc_split\r\n    end\r\n\r\n    subgraph Classify\r\n        direction LR\r\n        mod_class_cat([classifier categories])\r\n        mod_class_train[/training/]\r\n        mod_class_m[Model]\r\n        doc_split2(["`split documents *name_category_count*`"])    \r\n        mod_class[/Classify documents/]\r\n\r\n        subgraph Google Buckets\r\n            buck_ac@{ shape: docs, label: "A" }\r\n            buck_bc@{ shape: docs, label: "B" }\r\n            buck_dotc@{ shape: docs, label: "..." }\r\n        end\r\n\r\n        mod_class_cat --\x3e mod_class_train\r\n        mod_class_train --\x3e mod_class_m\r\n        mod_class_m --\x3e mod_class\r\n        doc_split2 --\x3e mod_class\r\n        mod_class --\x3e buck_ac\r\n        mod_class --\x3e buck_bc\r\n        mod_class --\x3e buck_dotc\r\n    end\r\n\r\n\r\n    Split -- split documents --\x3e Classify\r\n\r\n    subgraph Extract\r\n        direction LR\r\n        subgraph Google Bucket A\r\n            buck_a@{ shape: docs, label: "Documents" }\r\n        end\r\n        subgraph Google Bucket B\r\n            buck_b@{ shape: docs, label: "Documents" }\r\n        end\r\n\r\n        mod_ex_train_a[/training A/]\r\n        mod_ex_a[Model A]\r\n        buck_a --\x3e mod_ex_train_a --\x3e mod_ex_a\r\n\r\n        mod_ex_train_b[/training B/]\r\n        mod_ex_b[Model B]\r\n        buck_b --\x3e mod_ex_train_b --\x3e mod_ex_b\r\n\r\n        subgraph OGRRE\r\n           og_script[/Upload script/]\r\n           og_db[("`OGRRE<br>database`")]\r\n        end\r\n        buck_a --\x3e og_script --\x3e mod_ex_a -- data --\x3e og_db\r\n        buck_b --\x3e og_script --\x3e mod_ex_b-- data --\x3e og_db\r\n    end\r\n\r\n    Classify -- classified documents --\x3e Extract'}),"\n",(0,o.jsx)(n.h3,{id:"split",children:"Split"}),"\n",(0,o.jsx)(n.p,{children:"Typical input documents are multiple page PDFs, only some of which contain the data of interest.\r\nDifferent categories of report document have different boundaries, so they are labeled and identified."}),"\n",(0,o.jsx)(n.h4,{id:"training",children:"Training"}),"\n",(0,o.jsx)(n.p,{children:"The training set is created with the following manual (human) steps, performed on the collated raw PDFs uaing the Google DocAI web interface:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Identify the document boundaries"}),"\n",(0,o.jsx)(n.li,{children:"Assign a category, based on titles or content, to separate different collated document types"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Google DocAI needs at least 10 training documents and 2 testing documents for each category to automatically\r\napply the categories and boundaries to the rest of the collated documents."}),"\n",(0,o.jsx)(n.h4,{id:"application",children:"Application"}),"\n",(0,o.jsxs)(n.p,{children:["This 'model' of document boundaries and categories can now be applied to the rest of the collated documents.\r\nThen the processing workflow produces files like:\r\n",(0,o.jsx)(n.code,{children:"{original file name}_{Splitter label}_{Label count}"}),"."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"A useful original file name is the API number (e.g., if not inside the file itself)"}),"\n",(0,o.jsx)(n.li,{children:'The "Label countitle: Usage Guide\r\nsidebar_position: 2\r\nt" tracks the number of documents with the same \u201cSplitter Label\u201d for a given collated Document'}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"classify",children:"Classify"}),"\n",(0,o.jsx)(n.p,{children:"Once the documents have been split so that only the pages with the desired data are present,\r\nthey need to be grouped into categories based on document layout."}),"\n",(0,o.jsx)(n.h4,{id:"training-1",children:"Training"}),"\n",(0,o.jsxs)(n.p,{children:["Classifier category labels are based on the order of when each document type was identified,\r\nusing letters as follows: ",(0,o.jsx)(n.code,{children:"{Splitter Label}_{A,B,C,..}"}),".\r\nEach document receives one label."]}),"\n",(0,o.jsx)(n.p,{children:"The training set is created by labeling document types. As for the Split step, Google DocAI needs at least\r\n10 training and 2 testing documents for each document type."}),"\n",(0,o.jsx)(n.h4,{id:"application-1",children:"Application"}),"\n",(0,o.jsx)(n.p,{children:'The classifier model takes as input the splitter outputs from the previous step\r\nand categorizes them into different schema label "bins", which are mapped to different Google buckets for extraction.'}),"\n",(0,o.jsx)(n.h3,{id:"extract",children:"Extract"}),"\n",(0,o.jsx)(n.p,{children:"The final step in the workflow is to extract the data from each category of documents.\r\nTo do this, one must first train the processor, adding schema (field) labels for every field in the category of documents."}),"\n",(0,o.jsx)(n.h4,{id:"training-2",children:"Training"}),"\n",(0,o.jsx)(n.p,{children:"Unlike the Split and Classify steps for a field to included in a model, Google DocAI needs the field to be included on at least 10 training and 10 testing documents to create a model.\r\nOne model is trained for each category identified in the previous Classify step."}),"\n",(0,o.jsx)(n.p,{children:"Some important things to keep in mind for this process:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Field labels matching the document text reduces incorrect auto-labeling."}),"\n",(0,o.jsx)(n.li,{children:"Field labels may also be included into tables to facilitate grouping tabular data."}),"\n",(0,o.jsxs)(n.li,{children:["Unless otherwise required, the occurrence setting for fields inside of tables should be ",(0,o.jsx)(n.code,{children:"once"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["Documents that have a field labels with the occurrence setting ",(0,o.jsx)(n.code,{children:"required"})," will be excluded from training if that field cannot be detected."]}),"\n",(0,o.jsxs)(n.li,{children:["Field labels that may occur more than once should have the occurrence setting ",(0,o.jsx)(n.code,{children:"multiple"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["Keeping a record of the field labels, label type, occurrence, field groupings, and page order is best practice.","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"When training new models recording the fields that are disabled."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Below are details on the labeling process in Google DocAI:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Upon opening a document, Google attempts to auto-label any unconfirmed field colored in purple."}),"\n",(0,o.jsx)(n.li,{children:"Confirm field bounding boxes that are in the correct position."}),"\n",(0,o.jsx)(n.li,{children:"Edit field bounding boxes that are in the wrong position."}),"\n",(0,o.jsx)(n.li,{children:"Add field bounding boxes that are missed."}),"\n",(0,o.jsx)(n.li,{children:"Bounding boxes must include detected \u201ctext\u201d, Document with empty bounding boxes will be excluded from training."}),"\n",(0,o.jsxs)(n.li,{children:["Extracted text in the labeling process should not be edited.","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The text reader is not part of the model training process."}),"\n",(0,o.jsx)(n.li,{children:"Bounding boxes with edited text will be treated as incorrect detections during model testing in correctly reducing the accuracy of the model."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"application-2",children:"Application"}),"\n",(0,o.jsx)(n.p,{children:"The completed models are applied, in batch mode, with a script that is tied to the OGRRE tool. This process involves 2 steps:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Before running the script, create a mapping between the trained model and the documents for which it is intended (which correspond to a Google bucket)"}),"\n",(0,o.jsx)(n.li,{children:"The script takes this mapping and runs the Google DocAI processor to generate digitized data for each, storing the results in the tool database."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The combination of the document image (PDF) and digitized data are used by OGRRE to provide the interface for reviewing and correcting the digitized data."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(a,{...e})}):a(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>d});var i=t(96540);const o={},s=i.createContext(o);function r(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);